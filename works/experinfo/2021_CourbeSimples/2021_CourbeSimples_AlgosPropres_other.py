
# ###### LOOPS IN SURFACES : DECOMPOSITION IN THE MULTICURVE BASIS AND INTERSECTION ######

"""
    The main function of this module is multicurve_basis_decomposition.
    Given a multiloop in a closed surface minus 0 or 1 point, 
    it decomposes its trace function as a linear combination of multicurves.

    The surface of genus g>0 (with 1 puncture), is obtained by gluing a (truncated) 4g-gon.
    The identification pattern of the 4g-gon is encoded by a chord diagram :
    a cyclic word in which each letter appears twice (lower and upper case).
    For instance 'abABcdCD...' is the standard chodiag for a closed surface.
    A chord diagram for a sphere with k-holes is 'aAbBcCdD...'

    A loop is given from its cutting sequence wrt the chord diagram, or equivalently 
    as a product in the standard presentation of the fundamental group, 
    it is thus encoded as a linear word in the letters a, A, b, B, etc.
    A multiloop is a collection of loops, encoded as a sequence of loops.

    It relies on smooth_an_intersection and proceeds inductively.

    The function smooth_an_intersection relies on linked_words 
    The function linked_words relies on on linked_quadruples

"""

###### LIBRARIES ######

import numpy as np
import matplotlib.pyplot as plt
# from typing import List, Callable, Tuple

###### Multiloops to its multicurves decomopsition ######

"""
    The function sign_cross_ratio returns 1,0,-1 
    depending on whether the chords from a to A and from b to B :
    are disjoint, share one point on the boundary, or in the interior.
    This is given by the sign of a cross ratio.
    It assumes pattern is injective (each element appears once).
"""

def sign_cross_ratio(x, y, X, Y, chordiag):
    px = chordiag.index(x)
    pX = chordiag.index(X)
    py = chordiag.index(y)
    pY = chordiag.index(Y)
    return np.sign((px-py)*(px-pY)*(pX-py)*(pX-pY))


"""
    The function is_linked_pair returns 1,0,-1 depending on whether 
    w1[s1-1], w2[s2-1], w1[s1:], w2[s2:] are linked on the boundary 
    the linking being defined with respect to the chordiag.
    
    This corresponds to the relative position of the axes associated to 
    the infinite linear words with ...+w1+(w1[:s1]) extending to the left 
    and w1[s1:]+w1+... extending to the right.
    
    The answer is -1 if they cross, 1 if they are disjoint, 0 if tangent.
    (This can be determined by looking only length(l1)+length(l2) letters 
    since u^infty = v^infty iff uv = vu.)
"""


def is_linked_pair(word1, word2, s1, s2, chordiag):

    w1s = word1[s1-1].swapcase()
    w2s = word2[s2-1].swapcase()

    if w1s == w2s :
        return 0

    k = 0
    while((word1[(s1+k)%len(word1)] == word2[(s2+k)%len(word2)]) &\
        (k <= (len(word1)+len(word2)))):
        k += 1

    w1t = word1[(s1+k)%len(word1)]
    w2t = word2[(s2+k)%len(word2)]

    return sign_cross_ratio(w1s, w2s, w1t, w2t, chordiag)

"""
    The function find_intersection inspects linear cyclic permutations of words
    and returns the first pair of indices (s1, s2) such that :
    w1[s1-1], w2[s2-1], w1[s1:], w2[s2:] are linked on the boundary 
    the linking being defined with respect to the chordiag.
    If the loops do not intersect it returns None.
"""


def find_intersection(word1, word2, chordiag):

    for s1 in range(len(word1)):
        for s2 in range(len(word2)):
            if is_linked_pair(word1, word2, s1, s2, chordiag)==-1:
                return(s1, s2)

    return(None)

"""
    The function list_linked_pairs returns the list of all such pairs.
    The function intersection number computes the number of linked pairs.
"""

def list_linked_pairs(word1, word2, chordiag):

    pairs = []

    for s1 in range(len(word1)): 
        for s2 in range(len(word2)):
            if is_linked_pair(word1, word2, s1, s2, chordiag)==-1:
                pairs.append((s1, s2))

    return(pairs)

def intersection_number(word1, word2, chordiag):
    return len(list_linked_pairs(word1, word2, chordiag))

"""
    The function find_intersecting_loops finds two intersecting loops in the multiloop
    and returns the indices of the loop followed by the indices of the linked pairs.
"""

def find_intersecting_loops(multiloop, chordiag):
    for i, loopi in enumerate(multiloop):
        for j, loopj in enumerate(multiloop):
            fi = find_intersection(loopi, loopj, chordiag)
            if not fi :
                continue
            else : 
                return((i,j), fi)
    return(None)

###### ###### EN COURS D'EDITION ###### ######

"""
    The function reduce(word) returns the reduced cyclic representative 
    in the free group generated by the letters of the word
"""


def reduce(w):
    n=len(w)
    k=0
    
    while n > 1:  
        while k<n and w[(k+1)%n]!=w[k].swapcase():
            k=k+1
        
        if k==n:
            break
        
        elif k==n-1:
             w=w[1:n-1]
             n=n-2
             k=0
        
        else:
            w=w[0:k]+w[(k+2):n]
            n=n-2
            k=0
    return w

"""
The function inverse returns the inverse of the word loop.
"""
def inverse(loop):
    iloop=loop[::-1].swapcase()
    return iloop

def smooth_intersection(multiloop, chordiag):
    
    ((i,j), (si, sj)) = find_intersecting_loops(multiloop, chordiag)
    
    if i==j :
        # si, sj = min(si,sj), max(si,sj)
        s1=min(si,sj)
        s2=max(si,sj)
        
        #1ère résolution : w1W2w3
        #2ème résolution : w1w3,w2
        
        loop = multiloop.pop(i)
        
        W1=loop[:s1]
        W2=loop[s1:s2]
        W3=loop[s2:]
        sloop0 = reduce(W2)
        sloop2 = reduce(W1+W3)
        sloop1 = reduce(W1+inverse(W2)+W3)
        
        sm1 = multiloop + [sloop1]
        sm2 = multiloop + [sloop0, sloop2]
    
    else :
        
        #1ère résolution : w1w4w3w2
        #deuxième résolution : w1W3W4w2
        
        loopi = multiloop[i]
        loopj = multiloop[j]
        
        W1=loopi[:si]
        W2=loopi[si:]
        W3=loopj[:sj]
        W4=loopj[sj:]
        
        i1=min(i,j)
        i2=max(i,j)
        
        del multiloop[i2]
        del multiloop[i1]
        
        # cloopi = loopi[si:]+loopi[:si]
        # cloopj = loopi[sj:]+loopj[:sj]
        
        # sloop1 = cloopi + cloopj
        # sloop2 = cloopi + cloopj[::-1]
        
        sloop1=reduce(W1+W4+W3+W2)
        sloop2=reduce(W1+inverse(W3)+inverse(W4)+W2)
        
        
        sm1 = multiloop + [sloop1]
        sm2 = multiloop + [sloop2]

    return (sm1, sm2)

# multiloop=['aabbb']
# multiloops=[multiloop]
# print("Smooth I", smooth_intersection(['aBAbb'], 'abAB'))

def multicurve_basis_decomposition(multiloops, chordiag):
    
    multicurves = []
    # print()
    # print("Avant le while")
    # print("multiloops",multiloops)
    # print("multicurves",multicurves)
    
    while multiloops:
        multiloop = multiloops.pop()
        
        # print("Après le while")
        # print("multiloop",multiloop)
        # print()
        
        try :
            sm1, sm2 = smooth_intersection(multiloop, chordiag)
            # print("Après le try")
            # print("sm1,sm2",sm1,sm2)
            multiloops.extend([sm1, sm2])
            # print(multiloops)
        except TypeError:
            multicurves.append(multiloop)
            #print('error')
    
    return multicurves


###### ###### Boites à outils et brouillons ###### ######
"""
The function 'pente' returns the couple of integers corresponding to the slope of the curve 'loop'
that is suppose not to have intersection in the once-punctured torus. 
"""

def pente(loop):

    nba=loop.count("a")
    nbb=loop.count("b")
    nbA=loop.count("A")
    nbB=loop.count("B")
    
    return (nba-nbA,nbb-nbB)

"""
The function 'perm_cycle' returns the list of all the cyclic permutation of the word loop.
"""
def perm_cycle(loop):
    n=len(loop)
    cycle=[loop]
    for k in range(1,n):
        cycle=cycle+[loop[k:]+loop[:k]]
    
    return cycle

"""
The function 'est_bord' returns a boolean : 1 if 'loop' correspond to a boundary curve, 
that is a cyclic permutation of chordiag or the inverse of a cyclic permutation of chordiag. 
"""
def est_bord(loop,chordiag):
    #determine si une courbe est une courbe de bord
    
    cycle_bord=perm_cycle(chordiag)
    cycle_inv_bord=perm_cycle(inverse(chordiag))
    bord=cycle_bord+cycle_inv_bord
    
    return loop in bord


"""
The function 'slopes_multicurve' returns : b the number of boundary components of 
'multicurve' together with 'slopes', the list of all the slopes of the non-boundary 
components of 'multicurve'. (If the surface is a once-punctured torus, the slope
is supposed to be constant.)
"""

def slopes_multicurve(multicurve,chordiag):
    b=0
    slopes=[]
    
    for curve in multicurve:
        if est_bord(curve,chordiag):
            b=b+1
        else:
            na,nb=pente(curve)
            na=np.sign(nb)*na
            nb=np.abs(nb)
            slopes.append((na,nb))
                        
    return (b,slopes)

"""
The function 'point_multicurve' verifies that the slopes in multicurve are all 
the same and in this case, returns the number b of boundary components, 
the slope of the multicurve together with the multiplicity.
"""

def point_multicurve(multicurve,chordiag):
    
    b , slopes = slopes_multicurve(multicurve,chordiag)
    
    if len(set(slopes))!=1:
        return str(multicurve)+" is not a multicurve on the torus."
    else:
        (na,nb)=slopes[0]
        m=len(slopes)
        return (b,na,nb,m)


"""
The function polytope_multicurves returns the list of all the slopes (together 
with their multiplicity) of all the multicurves in 'multicurves'.
"""

def polytope_multicurves(multicurves,chordiag):
    nuage_X=[]
    nuage_Y=[]
    
    for multicurve in multicurves:
#        print("point_multi",point_multicurve(multicurve,chordiag))
        (b,na,nb,m)=point_multicurve(multicurve,chordiag)
        nuage_X.append(m*na)
        nuage_Y.append(m*nb)
    
    return (nuage_X, nuage_Y)

def affiche_polytope(multicurves,chordiag):
    nuage_X,nuage_Y=polytope_multicurves(multicurves,chordiag)
    plt.scatter(nuage_X,nuage_Y)
    plt.show()
    
    return


"""
FINAL : The function affiche_loop takes a loop (on the once-punctured torus) and 
print the polytope corresponding to the decomposition of the loop in the multicurve
basis.
"""

def affiche_loop(loop,chordiag):
    
    multicurves=multicurve_basis_decomposition([[loop]], chordiag)
    affiche_polytope(multicurves, chordiag)
    
    return

loop='bbbaaa'
chordiag='abAB'

affiche_loop(loop,chordiag)

